package net.thesilkminer.skl.interpreter.skd.structure

import com.google.common.base.Preconditions
import com.google.common.collect.ImmutableList
import com.google.common.collect.Lists
import net.thesilkminer.skl.interpreter.skd.AutoGeneratedProperty
import net.thesilkminer.skl.interpreter.skd.InternalProperty
import net.thesilkminer.skl.interpreter.skd.ReflectiveAccess
import net.thesilkminer.skl.interpreter.skd.api.structure.ArrayEntity
import net.thesilkminer.skl.interpreter.skd.api.structure.Entity
import net.thesilkminer.skl.interpreter.skd.api.structure.InfoPair
import net.thesilkminer.skl.interpreter.skd.api.structure.Property
import org.joou.ULong
import java.util.Optional

class EntityBase(name: String) : Entity, ArrayEntity {
    // We handle both entities and array-like entities in this class due to the similarities in
    // their implementations. Usually you should NOT do this but, whatever

    private val name: String

    private var id: String? = null

    @AutoGeneratedProperty("skd\$array")
    private var isArray = false

    private val childEntities : MutableList<Entity> = Lists.newLinkedList<Entity>()
    private val childInfoPairs : MutableList<InfoPair<*>> = Lists.newLinkedList<InfoPair<*>>()
    @ReflectiveAccess
    private val properties : MutableList<Property<*>> = Lists.newArrayList<Property<*>>()

    @AutoGeneratedProperty("skd\$id")
    @InternalProperty
    @ReflectiveAccess
    @Suppress("unused")
    private var skdId: String? = null

    @InternalProperty
    private var referenceEntity: Entity? = null

    init {
        Preconditions.checkArgument(name.chars().allMatch {
            val c = it.toChar()
            Character.isLetterOrDigit(c) ||
                    c == '-' ||
                    c == '_' ||
                    c == '$'// Allow for machine generated entities
        }, "Provided name is not valid. %s can only contain letters, digits, - and _", name)
        this.name = name
    }

    override fun getName(): String = this.name

    override fun getId(): Optional<String> = Optional.ofNullable(this.id)

    override fun setId(id: String) {
        this.id = if (id.isBlank()) null else id
    }

    override fun isArray(): Boolean = this.isArray

    override fun setArray(isArray: Boolean) {
        if (this.isArray() && isArray) return

        if (!this.isArray() && !isArray) return

        if (!isArray) {
            // All array-like entities can be treated as normal entities, but not
            // the contrary
            // If we are asked to set it as not an array-like entity, then allow it
            this.isArray = false
            this.referenceEntity = null
            return
        }

        // We need to check if this entity can be a valid array-like entity.
        if (!this.checkIfValidArray()) {
            throw IllegalStateException("Cannot consider entity as array-like due to contract violations")
        }

        this.isArray = true

        this.validate() // Mainly to make sure nothing has gone beyond control
    }

    override fun asArrayEntity(): ArrayEntity {
        if (!this.isArray) {
            throw ClassCastException("Entity cannot be considered an array-like entity")
        }
        return this
    }

    override fun getProperties(): Collection<Property<*>> {
        // By contract, autogenerated properties are stripped
        // Our parser uses reflection to access the property list directly if needed
        val list = Lists.newArrayList<Property<*>>()
        this.properties.filter { !it.getName().startsWith("skd\$") }.forEach { list.add(it) }
        return ImmutableList.copyOf(list)
    }

    override fun addProperty(property: Property<*>) {
        Preconditions.checkArgument(this.checkPropertyNameConstraints(property.getName(), alreadyPresent = true),
                "Property %s does not respect naming constraints", property)
        this.properties.add(property)
    }

    override fun removeProperty(property: Property<*>) {
        Preconditions.checkArgument(this.checkPropertyNameConstraints(property.getName()),
                "Property %s does not respect naming constraints", property)

        if (this.properties.remove(property)) {
            return
        }

        this.removePropertyByName(property.getName())
    }

    override fun removePropertyByName(name: String) {
        Preconditions.checkArgument(this.checkPropertyNameConstraints(name),
                "Name %s does not respect property naming constraints", name)

        this.findPropertyByName(name).ifPresent { this.properties.remove(it) }
    }

    override fun findPropertyByName(name: String): Optional<Property<*>> {
        Preconditions.checkArgument(this.checkPropertyNameConstraints(name),
                "Name %s does not respect property naming constraints", name)

        for (property in this.properties) {
            if (property.getName() == name) {
                return Optional.of(property)
            }
        }

        return Optional.empty()
    }

    // Note: this is not a deep copy because we want entities to be modified
    // What we do not want is people directly modifying this collection trying
    // to escape our list control and encapsulation.
    override fun getChildEntities(): Collection<Entity> = ImmutableList.copyOf(this.childEntities)

    override fun addChildEntity(entity: Entity) {
        Preconditions.checkArgument(this.checkEntityConstraints(entity),
                "Entity %s does not respect array-like entity constraints", entity)
        this.childEntities.add(entity)
        if (this.isArray && this.referenceEntity == null) this.referenceEntity = this.copyEntity(entity)
    }

    override fun removeChildEntity(entity: Entity) {
        if (this.childEntities.remove(entity)) {
            return
        }

        // Only non-array-like entities are allowed to perform a lookup according to the best guess
        // algorithm, so...
        if (this.isArray) {
            return
        }

        this.removeChildEntityByName(entity.getName())
    }

    override fun removeChildEntity(id: String) {
        this.findChildEntity(id).ifPresent { this.childEntities.remove(it) }
    }

    override fun removeChildEntityByName(name: String) {
        val matchingBestGuess = this.findChildEntitiesByName(name)
        if (matchingBestGuess.count() > 1) {
            throw UnsupportedOperationException("Multiple entities matching $name found")
        }
        if (matchingBestGuess.isEmpty()) {
            return
        }

        // For each is actually a single element
        matchingBestGuess.forEach { this.childEntities.remove(it) }
    }

    override fun removeAllChildEntitiesByName(name: String) {
        this.findChildEntitiesByName(name).forEach { this.childEntities.remove(it) }
    }

    override fun findChildEntitiesByName(name: String): Collection<Entity> {
        val list = Lists.newLinkedList<Entity>()
        for (entity in this.childEntities) {
            if (entity.getName() == name) {
                list.add(entity)
            }
        }
        return ImmutableList.copyOf(list)
    }

    override fun findChildEntity(id: String): Optional<Entity> {
        for (entity in this.childEntities) {
            if (entity.getId().isPresent && entity.getId().get() == id) {
                return Optional.of(entity)
            }
        }
        return Optional.empty()
    }

    override fun getChildInfoPairs(): Collection<InfoPair<*>> {
        if (this.isArray) return super.getChildInfoPairs()
        return ImmutableList.copyOf(this.childInfoPairs)
    }

    override fun addChildInfoPair(infoPair: InfoPair<*>) {
        if (this.isArray) return super.addChildInfoPair(infoPair)
        this.childInfoPairs.add(infoPair)
    }

    override fun removeChildInfoPair(infoPair: InfoPair<*>) {
        if (this.isArray) return super.removeChildInfoPair(infoPair)
        if (this.childInfoPairs.remove(infoPair)) return
        this.removeChildInfoPairByKey(infoPair.getKey())
    }

    override fun removeChildInfoPair(id: String) {
        if (this.isArray) return super.removeChildInfoPair(id)
        this.findChildInfoPair(id).ifPresent { this.childInfoPairs.remove(it) }
    }

    override fun removeChildInfoPairByKey(key: String) {
        if (this.isArray) return super.removeChildInfoPairByKey(key)
        val bestGuess = this.findChildInfoPairsByKey(key)
        if (bestGuess.count() > 1) throw UnsupportedOperationException("Multiple information pairs found for key $key")
        if (bestGuess.isEmpty()) return
        // Foreach actually acts on a single information pairs
        bestGuess.forEach { this.childInfoPairs.remove(it) }
    }

    override fun removeAllChildrenInfoPairByKey(key: String) {
        if (this.isArray) return super.removeAllChildrenInfoPairByKey(key)
        this.findChildInfoPairsByKey(key).forEach { this.childInfoPairs.remove(it) }
    }

    override fun findChildInfoPairsByKey(key: String): Collection<InfoPair<*>> {
        if (this.isArray) return super.findChildInfoPairsByKey(key)
        val list = Lists.newLinkedList<InfoPair<*>>()
        for (infoPair in this.childInfoPairs) {
            if (infoPair.getKey() == key) {
                list.add(infoPair)
            }
        }
        return ImmutableList.copyOf(list)
    }

    override fun findChildInfoPair(id: String): Optional<InfoPair<*>> {
        if (this.isArray) return super.findChildInfoPair(id)
        for (infoPair in this.childInfoPairs) {
            if (infoPair.getId().isPresent && infoPair.getId().get() == id) {
                return Optional.of(infoPair)
            }
        }
        return Optional.empty()
    }

    override fun asEntity(): Entity = this

    override operator fun get(index: ULong): Entity = this.childEntities[index.toInt()]

    override operator fun set(index: ULong, value: Entity) {
        this.childEntities[index.toInt()] = value
    }

    override operator fun get(index: Int): Entity = this[ULong.valueOf(index.toLong())]

    override operator fun set(index: Int, value: Entity) = this.set(ULong.valueOf(index.toLong()), value)

    override fun size(): ULong = ULong.valueOf(this.childEntities.count().toLong())

    override fun intSize(): Int = this.size().toInt()

    override fun clear() = this.childEntities.clear()

    override fun removeChildEntityByIndex(index: Int) = this.removeChildEntityByIndex(ULong.valueOf(index.toLong()))

    override fun removeChildEntityByIndex(index: ULong) {
        this.childEntities.removeAt(index.toInt())
    }

    override operator fun iterator(): Iterator<Entity> = this.childEntities.asIterable().iterator()

    override fun validate(autoFix: Boolean) {
        if (this.checkIfValidArray()) return
        if (!autoFix) throw IllegalStateException("Violations of array-like entity contract found")

        // Let's fix the wrong entities, shall we
        val reference = this.referenceEntity ?: throw IllegalStateException("refEntity == null; size != 0UL")

        val iterator = this.childEntities.listIterator()
        while (iterator.hasNext()) {
            val entity = iterator.next()

            // If the entity has a different name, then the only solution is
            // to delete the entity altogether. I mean, the entire entity
            // would need to be recreated anyway, so no point
            if (entity.getName() != reference.getName()) {
                iterator.remove()
                continue
            }

            var removed = false

            // Check the entity properties

            // Pass 1 -> Check every property with the reference
            for (entityProperty in ImmutableList.copyOf(entity.getProperties())) {
                // Skip auto-generated properties
                if (entityProperty.getName().startsWith("skd\$")) continue

                // Check if the property is present in the reference entity
                if (!reference.findPropertyByName(entityProperty.getName()).isPresent) {
                    // If we're inside here, then the property is not present in the reference
                    // entity: this means we have to remove it from the property list
                    entity.removeProperty(entityProperty)
                }
            }

            // Pass 2 -> Check for missing reference properties in entity
            for (referenceProperty in reference.getProperties()) {
                // Skip auto-generated as always
                if (referenceProperty.getName().startsWith("skd\$")) continue

                // Check if the reference property is present in the entity
                if (!entity.findPropertyByName(referenceProperty.getName()).isPresent) {
                    // We cannot really invent data, so... remove the entity
                    iterator.remove()
                    removed = true
                    break
                }
            }

            if (removed) continue

            // Now we check the entity's first level children

            // Pass 1 -> Check every children with the reference
            for (entityChild in ImmutableList.copyOf(entity.getChildEntities())) {
                // Gets the count for every single one and checks if they are the same
                val entityChildCount = entity.findChildEntitiesByName(entityChild.getName()).count()
                val referenceChildCount = reference.findChildEntitiesByName(entityChild.getName()).count()

                if (entityChildCount > referenceChildCount) {
                    // We would need to strip some from the entity, but which ones? It does not
                    // really work, so we remove the entity completely and we call it a day
                    iterator.remove()
                    removed = true
                    break
                }
                if (entityChildCount < referenceChildCount) {
                    // Same as above: we cannot invent data so we remove the entity again and we call
                    // it done
                    iterator.remove()
                    removed = true
                    break
                }
                // The count is the same, so this particular child should be satisfied, right?
            }

            if (removed) continue

            // Pass 2 -> Check every reference children with the one we're testing
            for (referenceChild in reference.getChildEntities()) {
                // Gets the count for every single one and checks if they are the same
                val entityChildCount = entity.findChildEntitiesByName(referenceChild.getName()).count()
                val referenceChildCount = reference.findChildEntitiesByName(referenceChild.getName()).count()

                if (entityChildCount != referenceChildCount) {
                    // Also here, there are some reference data that needs to be stripped or added:
                    // we cannot know nor invent, so we remove the entity directly
                    iterator.remove()
                    removed = true
                    break
                }

                // Same count
            }

            if (removed) continue

            // Okay, so this entity has passed validation
            // -> Same name
            // -> No properties more than the reference
            // -> No missing properties according to the reference
            // -> No children that are missing or more according to the reference and vice versa
            // Well, another one is gone then
            // This should be valid, so no removal
        }

        // Final check, to make sure validation has completed successfully
        if (!this.checkIfValidArray()) throw IllegalStateException("Unable to auto-fix contract violations")
    }

    private fun checkIfValidArray() : Boolean {
        if (this.childInfoPairs.isNotEmpty()) return false
        if (this.childEntities.count() <= 1) return true

        // Safe because we know this.childEntities.count() is >= 1
        val referenceEntity = this.childEntities[0]

        // Also safe because if count() >= 1 then, at least 0 and 1 are present
        for(i in 1 until this.childEntities.count()) {
            val entityToCheck = this.childEntities[i]

            if(!this.doesEntityStructureMatch(entityToCheck, referenceEntity)) return false
        }

        // Reference entity safe copy so nobody can mess with it
        this.referenceEntity = this.copyEntity(referenceEntity)

        return true
    }

    private fun copyEntity(entity: Entity) : Entity {
        val new = EntityBase(entity.getName())
        new.id = entity.getId().orElse(null)
        new.isArray = entity.isArray()
        for (child in entity.getChildEntities()) new.addChildEntity(child)
        for (child in entity.getChildInfoPairs()) new.addChildInfoPair(child)
        for (prop in entity.getProperties()) new.addProperty(prop)
        return new
    }

    private fun checkPropertyNameConstraints(name: String, alreadyPresent: Boolean = false) : Boolean {
        if (name == "id") return false
        if (PropertyBase.INTERNAL_PROPERTIES_NAMES.contains(name)) return false
        if (alreadyPresent && this.properties.filter { return it.getName() == name }.count() > 0) {
            return false
        }
        return true
    }

    private fun checkEntityConstraints(entity: Entity) : Boolean {
        if (!this.isArray) return true
        if (this.intSize() == 0) return true
        val ref = this.referenceEntity ?: throw IllegalStateException("refEntity == null; size != 0UL")
        return this.doesEntityStructureMatch(entity, ref)
    }

    // Used in array checks
    private fun doesEntityStructureMatch(entity: Entity, reference: Entity) : Boolean {
        // Check the entity name
        if (entity.getName() != reference.getName()) return false

        // Check the entity properties
        if (entity.getProperties().count() != reference.getProperties().count()) return false

        for (property in reference.getProperties()) {
            // Avoid checking autogenerated properties for matches
            if (property.getName().startsWith("skd$")) continue
            if (!entity.findPropertyByName(property.getName()).isPresent) return false
        }

        // Check first level children - child entities
        if (entity.getChildEntities().count() != reference.getChildEntities().count()) return false

        for (child in reference.getChildEntities()) {
            // Same first level children for entities actually means that
            // they have the same name, not necessarily same properties
            // correct? I mean, we allow only same name, then if specifications
            // actually change (telling us what is correct and what is not)
            // we can always edit it later
            val amountOfSameNameEntitiesInReference = reference.findChildEntitiesByName(child.getName()).count()
            val amountOfSameNameEntitiesInCheck = entity.findChildEntitiesByName(child.getName()).count()

            if (amountOfSameNameEntitiesInCheck != amountOfSameNameEntitiesInReference) return false

            // Now, if we have the same amount of entities (checked above) and the same amount of equally-named
            // entities (checked here), logic tells us the two entities names are the same. Thus, we can
            // skip all the other checks and run directly to the next bit
        }

        // Check first level children - child InfoPairs
        if (entity.getChildInfoPairs().count() != reference.getChildInfoPairs().count()) return false

        for (infoPair in reference.getChildInfoPairs()) {
            val amountOfSameKeyInfoPairInReference = reference.findChildInfoPairsByKey(infoPair.getKey()).count()
            val amountOfSameKeyInfoPairInCheck = entity.findChildInfoPairsByKey(infoPair.getKey()).count()

            if (amountOfSameKeyInfoPairInCheck != amountOfSameKeyInfoPairInReference) return false

            // Now, if we have the same amount of info pairs (checked above) and the same amount of equally-named
            // info pairs (checked here), logic tells us the two info pairs key are the same. Thus, we can
            // skip all the other checks and run directly to the next entity
        }

        return true
    }
}
